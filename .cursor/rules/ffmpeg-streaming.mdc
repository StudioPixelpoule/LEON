---
description: Patterns FFmpeg et HLS streaming pour LEON
globs: ["**/lib/*ffmpeg*", "**/lib/*transcode*", "**/lib/*hls*", "**/api/hls/**"]
---

# Patterns FFmpeg & Streaming — LEON

## Architecture Transcodage

```
┌─────────────────────────────────────────────────────────────────┐
│                        LEON Streaming                            │
├─────────────────────────────────────────────────────────────────┤
│  SimpleVideoPlayer (HLS.js)                                      │
│         │                                                        │
│         ▼                                                        │
│  /api/hls?path=...&segment=video_segmentN.ts                     │
│         │                                                        │
│         └──► Pré-transcodé? ──► Servir segments                 │
│              Non? ──► 404 (médias non transcodés masqués en UI) │
└─────────────────────────────────────────────────────────────────┘
```

## Pré-transcodage (ffmpeg-executor.ts)

### Stratégie : Single-pass multi-output avec fallback

1. **Single-pass** : une seule commande FFmpeg produit vidéo + N pistes audio
2. **Fallback séquentiel** : si ça échoue, vidéo seule puis audio un par un
3. **Sous-titres batch** : extraction de tous les sous-titres en une commande
4. **Validation post-transcodage** : vérification intégrité avant .done

### Structure sortie pré-transcodée

```
/transcoded/
  Film Name/
    video.m3u8          # Playlist vidéo seule
    video_segment0.ts   # Segments vidéo
    audio_0.m3u8        # Playlist audio piste 1
    audio_0_segment0.ts # Segments audio
    audio_1.m3u8        # Playlist audio piste 2
    playlist.m3u8       # Master playlist combinée
    subtitles.json      # Métadonnées sous-titres
    audio_info.json     # Métadonnées pistes audio
    sub_fra_0.vtt       # Sous-titres extraits
    .done               # Marqueur de complétion (après validation)
```

### Master Playlist

```m3u8
#EXTM3U
#EXT-X-VERSION:6

#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="French",LANGUAGE="fra",URI="audio_0.m3u8",DEFAULT=YES
#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="English",LANGUAGE="eng",URI="audio_1.m3u8"

#EXT-X-STREAM-INF:BANDWIDTH=5000000,AUDIO="audio"
video.m3u8
```

### GOP Dynamique

```typescript
// Détection framerate source + calcul GOP
const fps = await detectFramerate(filepath) // ffprobe r_frame_rate
const gopSize = Math.round(fps * SEGMENT_DURATION)
// 24fps × 2s = GOP 48, 25fps × 2s = GOP 50, 30fps × 2s = GOP 60
```

### Validation Post-Transcodage

Avant de créer `.done`, on vérifie :
- `video.m3u8` contient `#EXT-X-ENDLIST`
- Nombre de segments sur disque = nombre dans la playlist
- Chaque piste audio est complète
- Un segment aléatoire a une taille > 0

### Commande FFmpeg Single-pass

```typescript
// Single-pass multi-output (vidéo + audios en une lecture)
const args = [
  ...decoderArgs,
  '-i', filepath,
  // Output 1: Vidéo
  '-map', '0:v:0', '-vf', videoFilter,
  ...hardware.encoderArgs,
  '-g', String(gopSize), '-keyint_min', String(keyintMin),
  '-f', 'hls', '-hls_time', '2', '-hls_list_size', '0',
  '-hls_segment_filename', 'video_segment%d.ts',
  'video.m3u8',
  // Output 2: Audio 0
  '-map', '0:a:0', '-c:a', 'aac', '-b:a', '192k',
  '-f', 'hls', '-hls_time', '2',
  '-hls_segment_filename', 'audio_0_segment%d.ts',
  'audio_0.m3u8',
  // ... Output N pour chaque piste audio
]
```

## Configuration HLS.js

### Config Standard (pré-transcodé)

```typescript
// lib/hls-config.ts
export const HLS_BASE_CONFIG: Partial<HlsConfig> = {
  maxBufferLength: 45,
  maxMaxBufferLength: 90,
  maxBufferSize: 90 * 1000 * 1000,
  backBufferLength: 45,
  maxBufferHole: 0.3,
  nudgeOffset: 0.1,
  nudgeMaxRetry: 15,
  stretchShortVideoTrack: true,
  forceKeyFrameOnDiscontinuity: true,
  fragLoadingMaxRetry: 15,
  fragLoadingRetryDelay: 1000,
  fragLoadingMaxRetryTimeout: 120000,
  lowLatencyMode: false, // VOD, pas live
}
```

## Accélération Matérielle

### VAAPI (NAS Synology Intel Quick Sync)

```typescript
encoderArgs: [
  '-c:v', 'h264_vaapi',
  '-global_quality', '25',      // Qualité optimisée streaming 1080p
  '-async_depth', '4',           // Pipeline GPU 4 frames
  '-compression_level', '1',     // Vitesse > taille fichier
  '-maxrate', '8000k',
  '-bufsize', '16000k',
  '-profile:v', 'main',
  '-level', '4.1',
]
```

### CPU Fallback

```typescript
encoderArgs: [
  '-c:v', 'libx264',
  '-preset', 'veryfast',
  '-crf', '23',
  '-maxrate', '4000k',
  '-bufsize', '8000k',
]
```

## Sous-titres

| Format | Conversion | Notes |
|--------|------------|-------|
| SRT | WebVTT | Extraction FFmpeg |
| VTT | Natif | Pas de conversion |
| ASS/SSA | WebVTT | Extraction FFmpeg |
| PGS | Non supporté | Image bitmap |
| VOBSUB | Non supporté | Image bitmap |

## Bonnes Pratiques

### A faire

- Toujours utiliser le pré-transcodage (pas de temps réel)
- Segments de 2s pour seek rapide
- Validation post-transcodage systématique
- GOP dynamique adapté au framerate source
- Fallback séquentiel si single-pass échoue

### A éviter

- Plus de 2-3 transcodages simultanés (selon RAM)
- Segments trop longs (>6s)
- Créer .done sans validation
- Ignorer les erreurs HLS.js
- Transcodage sans timeout

## Commandes Debug

```bash
# Tester commande FFmpeg dans le container
docker exec leon ffprobe -v verbose /leon/media/films/test.mkv

# Logs transcodage
docker logs leon 2>&1 | grep -i transcode

# Vérifier transcodages en cours
curl http://localhost:3000/api/transcode/status
```
